from datetime import datetime
from matplotlib import animation
from matplotlib.lines import Line2D
import matplotlib.pyplot as plt
import numpy as np
from os.path import exists
from os import mkdir
from pandas import DataFrame

COLOR_VOLTAIQ = '#00dca0'
X_SCALING = 1E6
T_SCALING = 1E9



def animate(simulation: np.array, cell: DataFrame, props: dict, frames: int) -> animation.FuncAnimation:
    """Generates an animation (gif) from simulation results.

    The resulting animation plots pressure as a function of
    cell cross-section (grid), with one frame for each timestep,
    with cell layers color separated.

    TODO: Layer legend. Requires a sensible divergent colormap

    Args:
        simulation (np.array): Simulation data.
            See utils.fetch_simulation().
        cell (DataFrame): Stacked cell.
            See utils.assemble_cell().
        props (dict): Simulation properties.
            See example.ipynb.
        frames (int): Number of frames to process.
            Max is simulation.shape[0]

    Returns:
        animation.FuncAnimation: An animation (gif) of simulation.
    """

    def _drawframe(i: int) -> Line2D:
        """Generates pressure curve at one timestep.

        Args:
            i (int): Timestep index

        Returns:
            Line2D: Pressure curve at timestep i.
        """

        timestep = simulation[i, :]

        if sum(timestep) == 0.0:  # Don't want to plot flat timesteps.
            return None

        line.set_data(x * 1E6, timestep)

        return line,

    x = np.linspace(0, sum(cell.x), props['Nx'])

    fig, ax = plt.subplots(figsize=(5, 3))

    ax.set_xlim([0, x[-1] * 1E6])
    ax.set_ylim([-props['source_mag'], props['source_mag']])
    ax.set_xlabel('Cell cross-section [$\mathrm{\mu m}$]')
    ax.set_ylabel('pressure [Pa]')
    ax.set_title(f"1D Wave Simulation at {props['source_freq']/1e6} MHz")

    y = np.arange(-props['source_mag'] * 2, props['source_mag'] * 2 + 1)

    colormap = ['#b6b9bf', '#e6ebf7']
    x2 = 0

    for i, layer in cell.iterrows():
        x1 = x2
        x2 += layer['x']
        ax.fill_betweenx(y,
                         x1 * X_SCALING,
                         x2 * X_SCALING,
                         color=colormap[i % 2],
                         zorder=1)

    line, = ax.plot([], [], c=COLOR_VOLTAIQ, lw=2)

    animation_ = animation.FuncAnimation(fig=fig,
                                         func=_drawframe,
                                         frames=frames,
                                         interval=1,
                                         blit=False)

    return animation_


def plot_sensor(p_sensor: np.array, simulation_duration: float) -> None:
    """Plots sensor pressure as a function of time.

    Args:
        p_sensor (np.array): Sensor pressure.
        simulation_duration (float): Simulation duration to normalize
            horizontal axis.
    """

    p_sensor = p_sensor[abs(p_sensor) > 0.001]
    t = np.linspace(0, simulation_duration, len(p_sensor))

    fig, ax = plt.subplots(figsize=(5, 3), dpi=600)
    ax.plot(t * T_SCALING, p_sensor * 1000, c=COLOR_VOLTAIQ, linewidth=1)

    ax.set_xlim(left=0, right=simulation_duration * T_SCALING)
    ax.set_title('Sensor pressure')
    ax.set_xlabel('t [ns]')
    ax.set_ylabel('pressure [mPa]')


def save_animation(animation_: animation.FuncAnimation, fps: int) -> datetime.now:
    """Saves animation generated by animate().

    Args:
        animation.FuncAnimation: An animation (gif) of simulation.
        fps (int): Frames per second.

    Returns:
        datetime.now: For testing purposes.
    """
    now = datetime.now()
    now_parsed = now.strftime('%Y-%m-%d %H:%M:%S')
    folder = 'gifs/'

    if not exists(folder):
        mkdir(folder)

    animation_.save(f'{folder}simulation_{now_parsed}.gif',
                    writer='ffmpeg',
                    fps=fps)

    return now_parsed